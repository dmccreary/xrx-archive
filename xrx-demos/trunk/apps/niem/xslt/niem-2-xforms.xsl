<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet xmlns="http://www.w3.org/1999/xhtml" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:ev="http://www.w3.org/2001/xml-events" xmlns:c="http://niem.gov/niem/common/1.0" xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:u="http://niem.gov/niem/universal/1.0" xmlns:fn="http://www.w3.org/2005/xpath-functions" xmlns:xf="http://www.w3.org/2002/xforms" version="2.0">
<!-- Transform an XML Schema into an XForms instance editor. -->
<!-- Dan McCreary -->
<!-- 12/11/2006 -->
<!-- License: Creative Commons  2.5 Sharealike with Attribution -->

<!-- A screen-labels file can be generated from a central metadata registry -->
    <xsl:import href="code-tables/screen-labels.xml"/>
    <xsl:output method="xhtml" indent="yes" omit-xml-declaration="no"/>
    <xsl:template match="/">
        <html>
            <head>
                <title>XForms application generated from constraint schema.</title>
      
      <!-- generic stylesheet used by XForms -->
                <link rel="stylesheet" type="text/css" href="css/xforms-global.css"/>
                <link rel="stylesheet" type="text/css" href="css/field-widths.css"/>
                <xf:model>
                    <xf:instance xmlns="" id="default-instance" src="instance.xml"/>
                    <xsl:call-template name="binds-for-required-fields"/>
                    <xsl:call-template name="binds-for-dates"/>
                    <xsl:call-template name="binds-for-booleans"/>
                    <xsl:call-template name="import-code-tables"/>
          <!-- put the server-side call to save your form data here using -->
                    <xf:submission id="save" method="post" action="http://localhost:8080/save-form-data.xq" instance="default-instance"/>
                </xf:model>
            </head>
            <body>
                <p>Generated by schema2xforms version 0.4. License: Creative Commons  2.5 Sharealike with Attribution. </p>
                <xsl:apply-templates select="*"/>
            </body>
        </html>
    </xsl:template>
    <xsl:template match="xs:element[@name] | xs:element[@ref]">
        <xsl:choose>
      <!-- we have the root node -->
            <xsl:when test="matches(@name, 'Document$')">
      <!-- create an XForms group label with a lebel for each element -->
                <xf:group>
                    <xsl:attribute name="ref" select="concat('/', @name)"/>
                    <xf:label class="group-label">
                        <xsl:value-of select=" @name"/>
                    </xf:label>
                    <xsl:apply-templates/>
                    <xf:submit submission="save">
                        <xf:label>Save <xsl:value-of select="substring-before(@name, 'Document')"/>
                        </xf:label>
                    </xf:submit>
                </xf:group>
            </xsl:when>
            <xsl:when test="@name">
                <xf:group>
                    <xsl:attribute name="ref" select="@name"/>
                    <xf:label>
                        <xsl:attribute name="class">group-label</xsl:attribute>
                        <xsl:value-of select="@name"/>
                    </xf:label>
                    <xsl:if test="@type">
                        <xsl:variable name="type" select="@type"/>
                        <xsl:apply-templates select="//xs:complexType[@name=$type]">
                            <xsl:with-param name="in-element" select="'true'"/>
                        </xsl:apply-templates>
                    </xsl:if>
                    <xsl:apply-templates select="*"/>
                </xf:group>
            </xsl:when>
            <xsl:when test="@ref">
                <xsl:call-template name="leaf-node">
                    <xsl:with-param name="leaf-name" select="@ref"/>
                </xsl:call-template>
            </xsl:when>
        </xsl:choose>
    </xsl:template>

<!-- for complex types with a name, we will create XForms elements -->
    <xsl:template match="xs:complexType[@name]">
        <xsl:param name="in-element"/>
        <xsl:if test="$in-element='true()'"/>
        <xsl:apply-templates select="xs:sequence/xs:element|xs:choice/xs:element"/>
    </xsl:template>

<!-- no not process any documentation -->
    <xsl:template match="xs:documentation"/>
    <xsl:template match="xs:element/@name">
        <xf:group>
            <xsl:attribute name="ref" select="@name"/>
            <xs:label class="group-box">
                <xsl:value-of select="."/>
            </xs:label>
        </xf:group>
        <xsl:text>
      </xsl:text>
    </xsl:template>
    <xsl:template name="leaf-node">
        <xsl:param name="leaf-name" as="xs:string" required="yes"/>
   <!-- the namespace prefix -->
        <xsl:variable name="prefix" select="substring-before($leaf-name,':')"/>
    <!-- the unqualified element name -->
        <xsl:variable name="unqual-name" select="replace($leaf-name, '.*:', '')" as="xs:string"/>
        <xsl:variable name="screen-label" select="$lookup-labels/data/item[from=$unqual-name]/to"/>
        <xsl:choose>
            <xsl:when test="ends-with($leaf-name, 'Amount')                             or ends-with($leaf-name, 'Count')                             or ends-with($leaf-name, 'ID')                             or ends-with($leaf-name, 'Measure')                             or ends-with($leaf-name, 'Name')                             or ends-with($leaf-name, 'Percent')                             or ends-with($leaf-name, 'Year')                             ">
                <xf:input>
                    <xsl:attribute name="ref">
                        <xsl:value-of select="$leaf-name"/>
                    </xsl:attribute>
                    <xsl:attribute name="class" select="substring-after($leaf-name, ':')"/>
                    <xf:label>
                        <xsl:value-of select="$screen-label"/>: </xf:label>
                </xf:input>
            </xsl:when>
            <xsl:when test="ends-with($leaf-name, 'Code')">
                <xf:select1>
                    <xsl:attribute name="ref" select="$unqual-name"/>
                    <xf:label>
                        <xsl:value-of select="$screen-label"/>: </xf:label>
                    <xf:itemset>
                        <xsl:attribute name="nodeset">instance('<xsl:value-of select="$leaf-name"/>')/EnumeratedValues/Item</xsl:attribute>
                        <xf:label ref="Label"/>
                        <xf:value ref="Value"/>
                    </xf:itemset>
                </xf:select1>
            </xsl:when>
            <xsl:when test="ends-with($leaf-name, 'Date')">
                <xf:input>
                    <xsl:attribute name="ref" select="$leaf-name"/>
                    <xf:label>
                        <xsl:value-of select="$screen-label"/>: </xf:label>
                </xf:input>
            </xsl:when>
            <xsl:when test="ends-with($leaf-name, 'DateTime')">
                <xf:input>
                    <xsl:attribute name="ref" select="$leaf-name"/>
                    <xf:label>
                        <xsl:value-of select="$screen-label"/>: </xf:label>
                </xf:input>
            </xsl:when>
       <!-- do not process any document elements -->
            <xsl:when test="ends-with($leaf-name, 'Document')"/>
       <!-- this transform use a "full" appearance for booleans since we can force a user to select one value with no defaults -->
            <xsl:when test="ends-with($leaf-name, 'Indicator')">
                <xf:select1 appearance="full">
                    <xsl:attribute name="ref" select="$leaf-name"/>
                    <xf:label>
                        <xsl:value-of select="$screen-label"/>: </xf:label>
                    <xf:item>
                        <xf:label>Yes</xf:label>
                        <xf:value>yes</xf:value>
                    </xf:item>
                    <xf:item>
                        <xf:label>No</xf:label>
                        <xf:value>no</xf:value>
                    </xf:item>
                </xf:select1>
            </xsl:when>
            <xsl:when test="ends-with($leaf-name, 'Text')">
                <xf:textarea class="medium">
                    <xsl:attribute name="ref" select="$leaf-name"/>
                    <xf:label>
                        <xsl:value-of select="$screen-label"/>: </xf:label>
                </xf:textarea>
            </xsl:when>
            <xsl:otherwise>
                <b>
                    <font color="red">Error - type for <xsl:value-of select="$leaf-name"/> not found.</font>
                </b>
            </xsl:otherwise>
        </xsl:choose>
        <xsl:text>
      </xsl:text>
    </xsl:template>
    <xsl:template name="import-code-tables">
        <xsl:for-each select="//xs:element/@ref[matches(.,'Code$') or matches(.,'code$')]">
            <xf:instance xmlns="">
		<!-- remove all the characters before the colon if there is any colon -->
                <xsl:variable name="unqualified-name" select="replace(., '.*:', '')" as="xs:string"/>
                <xsl:attribute name="id" select="$unqualified-name"/>
                <xsl:attribute name="src" select="concat('../resources/code-tables/', $unqualified-name, '.xml')"/>
            </xf:instance>
        </xsl:for-each>
    </xsl:template>
   
   <!-- add bindings for all required fields -->
    <xsl:template name="binds-for-required-fields">
   <!-- for all elements that have a @ref attribute but no @minOccurs attribute -->
        <xsl:for-each select=" //xs:element[@ref and not( @minOccurs)]">
            <xf:bind>
                <xsl:attribute name="nodeset" select="concat('//', @ref)"/>
                <xsl:attribute name="required" select="'true()'"/>
            </xf:bind>
        </xsl:for-each>
    </xsl:template>
   
   <!-- add bindings for all dates -->
    <xsl:template name="binds-for-dates">
   <!-- for all elements that have a Date suffix -->
        <xsl:for-each select=" //xs:element[ends-with(@ref, 'Date')]">
            <xf:bind>
                <xsl:attribute name="nodeset" select="concat('//', @ref)"/>
                <xsl:attribute name="type" select="'xs:date'"/>
            </xf:bind>
        </xsl:for-each>
    </xsl:template>
   
   <!-- add bindings for booleans -->
    <xsl:template name="binds-for-booleans">
   <!-- for all elements that have an Indicator suffix -->
        <xsl:for-each select=" //xs:element[ends-with(@ref, 'Indicator')]">
            <xf:bind>
                <xsl:attribute name="nodeset" select="concat('//', @ref)"/>
                <xsl:attribute name="type" select="'xs:boolean'"/>
            </xf:bind>
        </xsl:for-each>
    </xsl:template>
</xsl:stylesheet>